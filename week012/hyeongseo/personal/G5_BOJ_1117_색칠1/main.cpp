// https://www.acmicpc.net/problem/1117

// 분류 : 수학, 구현

// 실패

/*
문제 접근
- 처음에는 전체 펼쳐져 있는 상태에서 접어가면서 구할려고 했음
- 근데 어디에 색칠되어있는지 모르잖슴?
- 그래서 접혀 있는 상태에서 펴가면서 색칠된 부분 구하자고 생각함
- 접혀 있는 상태와 가로로 접는 과정은 쉽게 구할 수 있음
- But 포인트는 세로로 접을 때 처리

------------------------------------------------------

시도
- 색칠된 구간과 겹쳐져 있는 구간의 시작 & 끝을 구해서 범위전마다 어떻게 복사되는지 계산함
- 또, 얼마나 겹쳐져 있는지를 double로 계산해서 비율로 계산함
    - 색칠 부분 1 ~ 5인데 접힌 부분 3 ~ 6이면 => 겹치는 구간 3 ~ 5임
    - 따라서, 1 ~ 5의 색칠된 개수 * 3 / 5 -> 이딴식으로 구했음;;

- But, 예제 1, 2는 맞았는데 나머지는 다 틀림

------------------------------------------------------

다른 사람 풀이 & 챗지피티
"x < f에 있는 영역은 2f - x 위치에 복제됨"

Point) 접힌 부분이 왼쪽이 더 넓은지 오른쪽이 더 넓은지
- 왼쪽이 더 넓은 경우 : 왼쪽 영역이 오른쪽에 복사됨
- 오른쪽이 더 넓은 경우 : 오른쪽의 영역이 왼쪽에 복사됨

- 경우의 수 나눠서 구하니 성공

------------------------------------------------------

총평
- 세로로 접는 경우의 수만 잘 나눴으면 쉽게 풀었을 문제
- 근데 이게 잘 안 떠오르는 게 문제;;
- 수학적 사고 방식?을 기를 필요가 있다
*/
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll w, h, f, c, lX, lY, rX, rY;

ll painted = 0; // 색칠된 곳

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> w >> h >> f >> c >> lX >> lY >> rX >> rY;

    // 처음 접혀져 있는 거 + 가로로 c번 접은 거
    painted = (rX - lX) * (rY - lY) * (c+1);

    // 세로로 접었을 때
    // 왼쪽 크기 <= 오른쪽 크기 : 왼쪽 영역이 복제됨
    if(f <= w / 2)
    {
        ll overlap = min(f, rX) - lX;
        if(overlap > 0) painted += overlap * (rY - lY) * (c + 1);
    }

    // 왼쪽 크기 > 오른쪽 크기 : 오른쪽 영역이 복제됨
    else
    {
        ll overlap = min(w, f + rX) - (f + lX);
        if(overlap > 0) painted += overlap * (rY - lY) * (c + 1);
    }

    cout << w*h - painted << "\n";
    
    return 0;
}